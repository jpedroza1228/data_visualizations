---
title: "COVID Data - Week 2"
format: 
  html:
    toc: true
---

Below is some of the code from my recreation and my milestone extension. I hope this helps with understanding the plotnine ecosystem as well as the usefulness of the `.loc` function.

# Setup & Loading Data/Packages

```{python}
#| label: 'setup'

# Import your packages here
import pandas as pd
from matplotlib import rcParams

# Set some pandas options
pd.set_option('display.max_columns', None)
pd.set_option('mode.copy_on_write', True)
rcParams.update({'savefig.bbox': 'tight'}) # Keeps plotnine legend from being cut off
```

```{python}
#| eval: false
#| echo: true

covid = pd.read_csv('data/covid.csv')

covid.head()
covid.info()
covid.columns
covid.columns.tolist()
covid.shape[0]
covid.shape[1]
covid.index

def glimpse(df):

    print(f"Rows: {df.shape[0]}")

    print(f"Columns: {df.shape[1]}")

    for col in df.columns:

        print(f"$ {col} <{df[col].dtype}> {df[col].head().values}")


glimpse(covid)

# this won't work because every filter needs its own set of parentheses
# covid.loc[covid['state'] == 'CA' & covid['cases'] > 0]

# like this
covid.loc[(covid['state'] == 'CA') & (covid['cases'] > 0)]


covid.loc[covid['state'].isin(['CA', 'WA', 'OR'])].value_counts('state')
west_covid = covid.loc[covid['state'].isin(['CA', 'WA', 'OR'])]

# numpy is already within your academy so this should work
import numpy as np

np.unique(west_covid['state'])
```

```{python}
#| echo: false
#| eval: true

covid = pd.read_csv('/home/jon/Documents/github_repos/data_visualizations/posit_python_cheatsheet/covid.csv')

covid.head()
covid.info()
covid.columns
covid.columns.tolist()
covid.shape[0]
covid.shape[1]
covid.index

def glimpse(df):

    print(f"Rows: {df.shape[0]}")

    print(f"Columns: {df.shape[1]}")

    for col in df.columns:

        print(f"$ {col} <{df[col].dtype}> {df[col].head().values}")


glimpse(covid)

# this won't work because every filter needs its own set of parentheses
# covid.loc[covid['state'] == 'CA' & covid['cases'] > 0]

# like this
covid.loc[(covid['state'] == 'CA') & (covid['cases'] > 0)]


covid.loc[covid['state'].isin(['CA', 'WA', 'OR'])].value_counts('state')
west_covid = covid.loc[covid['state'].isin(['CA', 'WA', 'OR'])]

# numpy is already within your academy so this should work
import numpy as np

np.unique(west_covid['state'])
```

## Subsetting Data

```{python}
#| label: 'recreation-subset'

covid.head()

covid_sub = covid.loc[covid['state'] == 'NY']
covid_sub.head()
```

# Visualizations

So I'm going to write out what is actually happening in plotnine during each step. This next part will have several code chunks but I am organizing it that way so I can have notes between each step. I included a step that should fold the code on the rendered document by clicking on the right side to *hide* the code. I'll also use terminology that you could see when working with others that use `plotnine`/`ggplot`.

I'll be creating the base layer for the plot. You'll notice that I don't have any points, lines, boxplots, etc. (Those are what we refer to as *geoms*) like *geom_point*, *geom_line*, and *geom_boxplot*. This is using my NY only dataframe.

```{python}
import plotnine as pn

pn.ggplot.show(
  pn.ggplot(covid_sub, pn.aes('date', 'cases'))
)
```

You should only be seeing an x- and y-axis. Now we'll add a line. As mentioned during our milestone session, the `group = 1` is necessary for forcing every row in the NY dataframe to be in 1 group. You can do some weird things by forcing a value to 1. Like an x-axis to 1. It's unlikely that you'll ever do it, but its possible. 

```{python}
pn.ggplot.show(
  pn.ggplot(covid_sub, pn.aes('date', 'cases'))
  + pn.geom_line(group = 1)
)
```

Now the issue with the recreation is that it asks for a practice that is not a *best practice*. For the recreation the base layer will only utilize the dataframe. Then you'll add additional layers to the base layer for the two line graphs. There is no rationale for creating this visual other than showing what plotnine can do and because it showcases the skills we've learned. I will show the code below that will show the best practice for conducting this visual. I mentioned that most if not all of you will forget the `group = 1` argument at some point plotting with plotnine and the reason why is because it is only really used when using `geom_line()`. So if you are not showing some form of forecasting or date variable, then you might forget to include it. 

```{python}
pn.ggplot.show(
  pn.ggplot(data = covid_sub)
  + pn.geom_line(mapping = pn.aes(x = 'date', y = 'cases', group = 1))
  + pn.geom_line(mapping = pn.aes(x = 'date', y = 'deaths', group = 1))
)

```

Here, it is also useful to add a color to both lines. They will not have a legend by default because the values are not within the aesthetics function.

```{python}
pn.ggplot.show(
  pn.ggplot(data = covid_sub)
  + pn.geom_line(mapping = pn.aes(x = 'date', y = 'cases', group = 1),
  color = 'dodgerblue')
  + pn.geom_line(mapping = pn.aes(x = 'date', y = 'deaths', group = 1),
  color = 'darkgreen')
)

```

We will be talking about this later, but this would be the better method for showing two different variables with the same information. 

```{python}
ny_long = covid_sub.melt(id_vars = ['date', 'state'], \
value_vars = ['cases', 'deaths'], \
var_name = 'cases_or_deaths', value_name = 'values')

pn.ggplot.show(
  pn.ggplot(ny_long, pn.aes('date', 'values'))
  + pn.geom_line(pn.aes(color = 'cases_or_deaths', group = 'cases_or_deaths'))
  + pn.theme_light()
)
```

# Visual From Milestone Session

During the milestone session, there was an instance of creating two different dataframes for two individual states, which you can see below. This led to some good talking points so I want to make sure this was in writing. Since the values for the x and y axises are the same, there is no need to create two different dataframes. Instead, we can put everything on the base layer.  

```{python}
pn.ggplot.show(
  pn.ggplot()
  + pn.geom_line(covid.loc[covid['state'] == 'CA'],
  pn.aes('date', 'cases', group = 1, color = 'state'))
  + pn.geom_line(covid.loc[covid['state'] == 'NY'],
  pn.aes('date', 'cases', group = 1, color = 'state'))
  + pn.theme_light()
)
```

So, we can filter our data to include both CA and NY and then have plotnine automatically create a legend and some colors. Here we have global rules so every layer below will follow the same color values.

```{python}
pn.ggplot.show(
  pn.ggplot(covid.loc[covid['state'].isin(['CA', 'NY'])],
  pn.aes('date', 'cases', color = 'state', group = 'state'))
  + pn.geom_line() 
  + pn.theme_light()
)

```

For instance, if you want to have points *over* your `geom_line()` function then you would put the points on the layer after the `geom_line()` as shown below. If you want them under your line then put the `geom_point()` before the `geom_line()` function. Since the `color = 'state'` argument is still on the base layer, the line and the points will be matching colors based on the state. 

```{python}
pn.ggplot.show(
  pn.ggplot(covid.loc[covid['state'].isin(['CA', 'NY'])],
  pn.aes('date', 'cases', color = 'state', group = 'state'))
  + pn.geom_line() 
  + pn.geom_point(alpha = .5)
  + pn.theme_light()
)

```

But maybe you want to have points that are gray and just have the lines that are different colors. Then you would put the `color = 'state'` argument only for the `geom_line()` function. This also shows the number one rule for plotnine and that is when to put values in the `pn.aes()` function. If you are using a column from your dataframe it goes in your aesthetics function. If you want a single value then it can go outside the aesthetics. Below for our line, we will have color based on the column `state`; however, all of our points will be gray no matter the state.  

```{python}
pn.ggplot.show(
  pn.ggplot(covid.loc[covid['state'].isin(['CA', 'NY'])],
  pn.aes('date', 'cases'))
  + pn.geom_line(pn.aes(color = 'state', group = 'state')) 
  + pn.geom_point(alpha = .3, color = 'gray')
  + pn.theme_light()
)
```

Below is the extension I showed during the milestone session. 

```{python}
#easiest option
#no_missing = covid.dropna()

# covid_sub = covid.loc[covid['state'] == 'NY']
no_missing = covid.loc[covid['state'] != 'NY']


pn.ggplot.show(
  pn.ggplot(data = no_missing, mapping = pn.aes(x = 'cases', y = 'deaths')) 
  + pn.geom_point(mapping = pn.aes(color = 'state'), alpha = .3)
  + pn.geom_smooth(method = 'lm', se = False)
  + pn.theme_light()
)
```

```{python}
pn.ggplot.show(
  pn.ggplot(data = no_missing, mapping = pn.aes(x = 'cases', y = 'deaths'))
  + pn.geom_point(alpha = .2, color = 'gray')
  + pn.geom_point(data = covid_sub, color = 'red', alpha = .8)
  + pn.theme_light()
)
```

```{python}
pn.ggplot.show(
  pn.ggplot(data = no_missing, mapping = pn.aes(x = 'cases', y = 'deaths'))
  + pn.geom_point(alpha = .2, color = 'gray')
  + pn.geom_point(data = covid_sub, color = 'red', alpha = .8)
  + pn.geom_smooth(data = covid_sub, method = 'lm', se = False, color = 'red')
  + pn.theme_light()
)
```

# Using .loc

Below is the link that shows why to use `.loc[]` function from the pandas website. If you are simply choosing columns, such as something like `covid[['state', 'date', 'cases']]` then that is fine, but once you include rows it is best to use `.loc[]/.iloc[]`.

[Link for using .loc](https://pandas.pydata.org/pandas-docs/version/1.0.2/getting_started/intro_tutorials/03_subset_data.html#how-do-i-filter-specific-rows-from-a-dataframe)

[Here is some more information for indexing based on `iloc/loc`.](https://pandas.pydata.org/pandas-docs/version/1.0.2/user_guide/indexing.html#different-choices-for-indexing)

```{python}
# showing similar findings
(covid[covid['state'] == 'CA'] == covid.loc[covid['state'] == 'CA']).head()
```

```{python}
# we'll talk dates at a later time
covid['date'] = pd.to_datetime(covid['date'])
covid['day'] = covid['date'].dt.day
covid['month'] = covid['date'].dt.month
covid['year'] = covid['date'].dt.year

covid.head()

covid_cases = covid[['state', 'month', 'year', 'cases']]\
  .groupby(['state', 'month', 'year']).max('cases')

# indices include state, month, year
covid_cases.head()

# can reset indices to then have state, month, and year as columns
covid_cases.reset_index().head()

covid_cases2 = covid_cases.reset_index()

covid_cases2.loc[covid_cases2['cases'] > 50000, 'state']

covid_cases2[covid_cases2['cases'] > 50000]

# returns error because you cannot select a different 
# covid_cases2[covid_cases2['cases'] > 50000, 'state']
```

```{python}
extra_covid = covid_cases2

# does not work because it cannot infex the specific row and column of interest (state)
# extra_covid[(extra_covid['cases'] > 900) & (extra_covid['state'] == 'AK'), \
# 'state'] = 'Most Alaska'

extra_covid.loc[(extra_covid['cases'] > 900) & (extra_covid['state'] == 'AK'), \
  'state'] = 'Most Alaska'
# better option would be to use something like this
# max_ak = extra_covid.loc[extra_covid['state'] == 'AK', 'cases'].max()
# extra_covid.loc[(extra_covid['state'] == 'AK') & \
# (extra_covid['cases'] == max_ak), 'cases'] = 'Most Alaska'

extra_covid.loc[(extra_covid['state'].str.startswith('AK')) | \
  (extra_covid['state'].str.startswith('Most'))]
```

Reasons for using the `.loc[]/iloc[]` function:

1. You can use it to filter rows based on boolean filter and then choose a specific column or list of columns.

2. You can assign values when using these functions.

3. It is slightly faster, but this is not really a big selling point.

4. It allows you to explicitly index rows based on the filter. While most of the time without .loc, you'll be fine, there is a chance you can introduce unwanted behaviors. 


```{python}


```
